/* Factory.java has a collection of methods to build complex FIFOs *//* IES  17 May 1997 *//* updated 9 September 1997 *//* updated IES 6 June 1997 */package ljSim.parts;//import ljSim.basicA.Delay;import ljSim.basicA.Messenger;import ljSim.basicA.Time;import ljSim.commands.Command;import ljSim.commands.JointCommand;import ljSim.commands.SortedJointCommand;import ljSim.commands.SquareQueue;import ljSim.jointPkg.DemandMergeJoint;import ljSim.jointPkg.JointFactory;import ljSim.jointPkg.OneInOneOutJoint;import ljSim.jointPkg.RoundRobinForkJoint;import ljSim.jointPkg.RoundRobinJoinJoint;import ljSim.jointPkg.RoundRobinJoint;import ljSim.jointPkg.SinkJoint;import ljSim.jointPkg.SourceJoint;import ljSim.components.Component;import ljSim.components.Group;import ljSim.components.Joint;import ljSim.components.Link;public class Factory {///Test code//    private int jointNums= 1;  //  private int linkNums= 1;   static private Messenger myMessenger = Messenger.please("Factory", 2);    public Factory(Messenger M) {        myMessenger = (M != null) ? M : Messenger.please("Factory", 2);        return;    }// end of PathFactory constructor   //to test SquareQueue    static public void testQ()        {     //       SquareQueue.testMe();            Command.sq= new SquareQueue(myMessenger);            SortedJointCommand[] ca;            ca= new SortedJointCommand[10];            JointCommand[] cb;            cb= new JointCommand[10];            Joint[] ja;            ja= new Joint[10];            Joint j= SinkJoint.please("testJoint", null);             Link la= Link.please("testLink", j);            for(int i= 1; i<9 ; i++)                {                    ca[i]= SortedJointCommand.please (j);                    ca[i].setTime(Time.please(i*1000));                    ja[i]= OneInOneOutJoint.please(null, j);                    cb[i]= ja[i].makeAwakeUpCommand();                    cb[i].setTime(Time.please(i*400));                }            ca[5].setTime(Time.please(3500)); //this one is out of order                        Command.sq.printPendingTasks();                        for(int i= 1; i<9 ; i++)                {                    Time tt= Time.please(i*1010);                    ca[i].enQueueMe();                }            Command.sq.printPendingTasks();           for(int i= 1; i<9 ; i++)  //          for(int i= 8; i>0 ; i--)                {                    Time tt= Time.please(i*440);                    cb[i].enQueueMe(tt);                }                        Command.sq.printPendingTasks();                    }//end of testMe    ///has no useable    //This method tests a single long FIFO    static public void testFifo()        {            Command.setup();            new Group (null); //have to make the top            Component p= Component.getTheParent();            //make the fixed Joints            SourceJoint src= SourceJoint.please("src", p);            SinkJoint snk= SinkJoint.please("snk", p);                      //wire them up            JointFactory.makeFIFO(p, src, snk, 8);                   //exhibit the topology            Component.printTheComponents();            Joint.checkJointTopology();            Joint.clearAllJoints();            Link.clearAllLinks();            Link.printTopology();            Joint.printTopology();           //make initializers and do            src.makeStartTask(Time.zeroTime);            snk.makeQuitTask(Time.theLastTime);            Command.printPendingTasks();            Command.doManyTasks(200);            Link.printStatistics();            Joint.printStatistics();            Command.printStatistics();        }//end of testFifo    ///out of sequence    //this method connects a roundRobinFork and roundRobin Joint    //connected by three short FIFIs.     public void testTwinFifoS(){        //this is a test of TWO FIFOs in parallel        Command.setup();        new Comp ("TOP",null); //have to make the top        Component p= Component.getTheParent();        Component groupA= new Comp ("groupA", p);        Component groupB= new Comp ("groupB", p);        SourceJoint src= SourceJoint.please("src", groupA);        SinkJoint snk= SinkJoint.please("snk", groupA);        JointFactory.makeFIFO(groupA, src,snk,5);        JointFactory.makeFIFO(groupB, src,snk,3);        Component.printTheComponents();        Joint.checkJointTopology();        Joint.clearAllJoints();        Link.clearAllLinks();        Link.printTopology();        Joint.printTopology();  //      OneInOneOutJoint.printTopology();                src.makeStartTask(Time.zeroTime);        Command.doManyTasks(200);        Link.printStatistics();        Joint.printStatistics();        Command.printStatistics();        return ;}//END of testAfifo         static public void testRoundRobinA(){         Command.setup();         new Group (null); //have to make the top         Component p= Component.getTheParent();         SourceJoint src= SourceJoint.please("src", p);         SinkJoint snk= SinkJoint.please("snk", p);                  RoundRobinForkJoint f= RoundRobinForkJoint.please("forker", p);         RoundRobinJoinJoint j= RoundRobinJoinJoint.please("joiner", p);         JointFactory.makeFIFO(p, src, f, 2);         JointFactory.makeRR(p, f, j, 3, 2);         JointFactory.makeFIFO(p, j, snk, 2);                  Component.printTheComponents();         Joint.checkJointTopology();         Joint.clearAllJoints();       //  Link.clearAllLinks();         Link.printTopology();         Joint.printTopology();         Link.printTopology();   ///has no useable         src.makeStartTask(Time.zeroTime);         snk.makeQuitTask(Time.theLastTime);         Command.printPendingTasks();         Command.doManyTasks(200);         Link.printStatistics();         Joint.printStatistics();         Command.printStatistics();         }//end of testRoundRobinA          static public void testRoundRobinB(){         Command.setup();         new Group (null); //have to make the top         Component p= Component.getTheParent();         SourceJoint src= SourceJoint.please("src", p);         SinkJoint snk= SinkJoint.please("snk", p);                  //make the Forker and joiner         RoundRobinJoint f= RoundRobinJoint.please("forker", p, "forkType");         f.addActions(1, 3);         RoundRobinJoint j= RoundRobinJoint.please("joiner", p, "joinType");         j.addActions(3, 1);         JointFactory.makeFIFO(p, src, f, 2);         JointFactory.makeRR(p, f, j, 3, 2);         JointFactory.makeFIFO(p, j, snk, 2);                  Component.printTheComponents();         Joint.printTopology();         Joint.checkJointTopology();         Joint.clearAllJoints();         Link.printStatistics();   //      Link.clearAllLinks();         Link.printTopology();            src.makeStartTask(Time.zeroTime);         snk.makeQuitTask(Time.theLastTime);         Command.printPendingTasks();         Command.doManyTasks(200);         Link.printStatistics();         Joint.printStatistics();         Command.printStatistics();         }//end of testRoundRobinB          // this is the test of the demand merge     // it has two sources     static public void testDemandMerge()     {         //make the          Command.setup();         new Group (null); //have to make the top         Component p= Component.getTheParent();         //make the fixed Joints         SourceJoint srcA= SourceJoint.please("srcA", p);         SourceJoint srcB= SourceJoint.please("srcB", p);         SinkJoint snk= SinkJoint.please("snk", p);         DemandMergeJoint merge= DemandMergeJoint.please("mrg", p);              //wire them up         JointFactory.makeFIFO(p, srcA, merge, 1);         JointFactory.makeFIFO(p, srcB, merge, 1);         JointFactory.makeFIFO(p, merge, snk, 2);                          //exhibit the topology         Component.printTheComponents();         Joint.checkJointTopology();         Joint.clearAllJoints();         Link.clearAllLinks();         Link.printTopology();         Joint.printTopology();         //make initializers and do         srcA.makeStartTask(Time.zeroTime);         srcB.makeStartTask(Time.zeroTime);         snk.makeQuitTask(Time.theLastTime);                  myMessenger.line("");         myMessenger.line("PENDING TASKS ARE");         Command.printPendingTasks();         myMessenger.line("");         myMessenger.line("START SIMULATION");         Command.doManyTasks(200);         Link.printStatistics();         Joint.printStatistics();         Command.printStatistics();     }//end of testDemandMerge        private class Comp extends Component    {        private int comNumber = 1;        //constructor        private Comp (String name, Component parent)            {                super (parent);                String n= (name== null) ? ("C:" + comNumber) : name;                setName(n);            }                public String getTypeString()            {return "TestComponent";}                public void masterClear()            {return ;}    }// end of class Comp    }// end of class Factory